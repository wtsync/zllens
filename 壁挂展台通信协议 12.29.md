壁挂展台通信协议
=============
# 修改记录
2016.12.7 WT NACK添加一个字段，用于返回错误代码，比如开机自检失败、未知命令、步进电机位置超出范围、命令格式错误。
2016.12.7 WT 添加一个获取当前位置的命令。
2016.12.29 WT 将STEP变成工厂调试命令，实际用户使用命令是ZOOM to，参数是倍数。
2016.12.29 WT 添加几个调试命令

# 通信协议格式

|协议版本号|数据长度|命令|数据|校验和|
|------|------|-----|---|------|
|1BYTE |1BYTE |1BYTE|...|1BYTE |

* 数据长度定义于包长度。
* 校验和为从协议版本号第一个字节到数据最后一个字节每个BYTE加起来的值。

PC发送给MCU，命令有多种，每一种命令都可能有不同的参数
MCU发送给PC，命令有ACK／NACK两种。NACK有一个类型，ACK有多种类型，类型后面可能还有数字。

# 通信流程

上位机(PC机) 发送命令和相关参数，下位机接收处理后返回命令和相关参数。上位机和下位机以全双工模式工作。串口速度为115200bps。
每一条数据下位机对每一条命令必须回复ACK或者NAK。


# 通信命令定义

|返回第一字节|再分类|返回第二字节|数字|ACK参数个数|CMD或者原因|数字|参数个数|参数意义|备注|
|---|---|---|---|---|---|---|---|---|---|
|不返回|||||分包|||||
|不返回|||||超时|||||
|||||||||||
|NACK||NACK_SUM|1||校验和错误|||||
|||NACK_CMD_NOT_FOUND|2||未知命令|||||
|||NACK_PARAM_COUNT|3||参数个数不对|||||
|||NACK_PARAM_OUT_OF_RANGE|4||参数超出范围|||||
|||NACK_SELF_TEST_FAIL|5|2|镜头开机归零自检失败。第一个参数表示哪个步进电机，1表示ZOOM的，2表示FOCUS的。第二个参数表示步进电机自检错误类型。||||自检失败，需要工厂来看到底哪里出错了|
|||NACK_IAP_PINS_TYPE|6||IAP设置中PINS TYPE错误|||||
|||NACK_IAP_ZOOM_MAX|7||IAP设置中ZOOM_MAX(AF_TABLE_SIZE)错误|||||
|||NACK_IAP_ZOOM_AF_TABLE_BIGGER|8|1|IAP设置中ZOOM_AF_TABLE错误，不是一个比一个大|||||
|||||||||||
|ACK|通用|ACK_VERSION_GET|1|N|VERSION_GET|1|0|||
|||||||||||
||工厂|ACK_STEP_GET|2|4|STEP_GET|2|0|||
|||ACK_DONE 实际是**没有第二字节**|||STEP_SET|3|4|一二个组成是ZOOM stepper位置（可以为负数），三四个FOCUS stepper位置（可以为负数）||
|||ACK_DONE|||CONFIG_PINS_TYPE|4|1|选择哪一种PIN的连接方式||
|||ACK_DONE|||CONFIG_ZOOM_MAX|5|1|最小ZOOM 1，最大可以到ZOOM多少||
|||ACK_DONE|||CONFIG_ZOOM_AF_TABLE|6|5|第一个是“多少倍”，从1开始计数，第二三个ZOOM stepper位置（可以为负数），第四五个FOCUS stepper位置（可以为负数）||
||||||||||
||用户|ACK_DONE|||SELF_TEST (BACK_TO_LAST_POS)|7|0||用户觉得丢步导致了聚焦不清，于是再次检测一下零点|
|||ACK_DONE|||ZOOM_IN|8|0||先寻找当前STEP对应的最近的ZOOM AF TABLE，然后运动|
|||ACK_DONE|||ZOOM_OUT|9|0|||
|||ACK_ZOOM_GET|3|2|ZOOM_GET|0x0A|0|||
|||ACK_BUTTON|4|1|PC什么也没做|||薄膜按键值||

光机的步进电机，移动范围均为“正、负”范围，并且超过了256，于是使用两个字节，int16_t形式。高字节在前，低字节在后。

```
 0x7fff --> 7f ff
 0x1000 --> 10 00
      1 --> 00 01
      0 --> 00 00
-     1 --> ff ff
-0x1000 --> f0 00
-0x7fff --> 80 01
-0x8000 --> 80 00
```

代码

```
unsigned char int_to_H(int n){
    if((n < -0x8000) || (n > 0x7fff)){
        return 0;
    }
    if(n >= 0){
        return n >> 8;
    }else{
        return (0x10000+n) >> 8;
    }
}
```

正数代表当前zero detect输出为高！0和负数代表当前zero detect输出为低。


### 上电自检

首先当然是那些配置，不能太离谱，比如PINS_TYPE成了5，ZOOM_MAX为65535什么的就太离谱了。
然后才是检测”零点“和丢步。

1. 如果现在输出高，就往回跑一段，跑到为低。
2. 当前为低，向前跑，跑到刚好为高，记录这一点为“1点”，它前面一点就是“零点”。
3. 向前跑一定步数（比如100），然后向后跑，应该为高。
4. 后跑一步，应该输出低。
5. 后跑一定步数（比如20），然后向前跑，应该为低。
6. 向前跑一步，应该为高。

以上步骤之后，表明自检测成功。

步进电机错误类型也是如此定义的

|类型|意义|
|---|---|
|1|上电后发现高，然后往低跑，结果跑了1000步还是没发现低|
|2|上电后直接发现为低，或者上一步跑到了低，然后向高跑，结果没发现高|
|3|前跑100，后跑100，结果居然不是高|
|4|后跑1步，居然不是低|
|5|后跑20步，前跑20，居然不是低|
|6|前跑1，居然不是高|
|0|由于读取工厂配置失败，各种IO口，最大最小限制都没能读取到，无法进行自检，也就没有进行自检。需要重新写入工厂配置，然后重启自检|

出现错误了，PC只能提示“开机自检失败，请再次上电试一下，如果还是提示此错误，请联系工厂维修”。
这里工厂需要提示”是烧录错误“还是”丢步错误“，用户不需要提示。

### 上表中一些补充定义

|参数值|意义|
|---|---|
|1|ZOOM stepper跑了1000步都没找到0点|
|2|ZOOM stepper零点之后，外100步，内99步，已经触发零点了|
|3|ZOOM stepper零点之后，外100步，内99步，再内1步，没有触发零点了|
|4|FOCUS stepper跑了1000步都没找到0点|
|5|FOCUS stepper零点之后，外100步，内99步，已经触发零点了|
|6|FOCUS stepper零点之后，外100步，内99步，再内1步，没有触发零点了|

不同光机使用不同IO口，所以工厂需要预先CONFIG_PINS_TYPE设置PINS的意思，该命令的参数的含义

|参数值|意义|
|---|---|
|1|大光机，22倍，1/4寸，KL501的，22p排线线序|
|2|小光机，10倍，1/3寸，22p排线线序|

ACK带参数的有3个，ACK_VERSION_GET，ACK_STEP_GET，ACK_ZOOM_GET，这些参数的意义入下表

|ACK类型|参数个数|参数意义|
|---|---|---|
|ACK_VERSION_GET|8|VERSION的一连串数字而已，随便选择的8个，也可以1个，2个，3个什么的|
|ACK_STEP_GET|2|第一个是ZOOM stepper的位置，第二个FOCUS stepper位置|
|ACK_ZOOM_GET|2|第一个是当前zoom大小（1～MAX），第二个是最大支持的ZOOM（MAX），PC程序发送ZOOM_IN，ZOOM_OUT之后，如果到达最大或者最小，MCU并不返回NACK提示当前已经到限制值了，而是什么也不错，需要PC程序自己再发送ZOOM_GET来判断是否已经到达限制值了，然后选择性的再GUI上做一些提示或者不提示|

### 例子

下表数字均为16进制，省略0x前缀：

|||PC|MCU|
|---|---|---|---|
|NACK|SUM错误||11,2,**0a,01**,sum|
|NACK|未知命令||11,2,**0a,02**,sum|
||||
|ACK通用|VERSION|11,1,**01**,sum|11,10,**ac,1,11,22,33,44,55,66,77,88**,sum|
||||
|ACK工厂|STEP_GET|11,1,**02**,sum|11,6,**ac,2,00,12,00,34**,sum|
||STEP_SET|11,5,**03,00,12,00,34**,sum|11,1,**ac**,sum|
||CONFIG_PINS_TYPE|11,2,**04,01**,sum|11,1,**ac**,sum|
||CONFIG_ZOOM_MAX|11,2,**05,0a**,sum|11,1,**ac**,sum|
||CONFIG_ZOOM_AF_TABLE|11,6,**06,01,00,12,00,00**,sum|11,1,**ac**,sum|
||||
|ACK用户|SELF_TEST (BACK_TO_LAST_POS)|11,1,**07**,sum|11,1,**ac**,sum|
||ZOOM_IN|11,1,**08**,sum|11,1,**ac**,sum|
||ZOOM_OUT|11,1,**09**,sum|11,1,**ac**,sum|
||ZOOM_GET|11,1,**0a**,sum|11,4,**ac,3,2,0a**,sum|

### 对于未来的扩展

用户PC软件，是否需要PINS_TYPE_GET？用来显示当前是什么机型，是展台？高拍仪？9系列？c系列？等等。
PC软件，ZOOM_GET可以得到ZOOM_MAX，不需要一个ZOOM_MAX_GET命令。

**注意，新加了一个需求，就是壁挂展台的薄膜按键（通过STC的MCU）能够直接调节zoom，那么就是镜头收到薄膜按键的命令之后，直接运动。这时候可以选择通知PC软件。也就是ACK_ZOOM不仅仅是PC发送ZOOM_GET之后发送，任意时刻都可能发送。**


**预留ACK_BUTTON，可能设置为薄膜按键之后，通知一下PC软件。**


**预留ACK_LED，薄膜按键开关LED之后，通知PC软件**

# 命令时间

命令必须在100ms内发完，超时清空寄存器，指令不执行


